# Multi-Language Architecture for 1-Click GitHub Security

## Overview

This document outlines the transformation from `1-click-rust-sec` to `1-click-github-sec` - expanding beyond Rust to support multiple programming languages while maintaining the same security-first principles.

## Current Architecture Analysis

### Language-Specific Components (Rust-Only)
- **Cargo.toml security configuration**: `overflow-checks = true`, deny.toml
- **Rust toolchain installation**: cargo-audit, cargo-deny, cargo-auditable, cargo-geiger, cargo-machete
- **Rust-specific pre-push checks**: `cargo fmt`, `cargo clippy`, `cargo test`, `cargo audit`
- **Cargo-specific CI workflows**: Rust toolchain setup, cargo caching, auditable builds

### Generic Components (Language-Agnostic)
- **Secret detection**: gitleakslite/gitleaks patterns work across all languages
- **SHA pinning validation**: GitHub Actions pinning is universal
- **Git hooks infrastructure**: Pre-push hook framework
- **GitHub security features**: Dependabot, branch protection, secret scanning
- **CI/CD pipeline structure**: Workflow generation, job orchestration
- **Cryptographic verification**: SHA256 checksums, GPG signatures
- **Logging and transaction system**: Framework-level infrastructure

## Multi-Language Security Framework

### 1. Language Detection and Selection

```bash
# Auto-detection priority order
detect_project_language() {
  if [[ -f "Cargo.toml" ]]; then
    echo "rust"
  elif [[ -f "package.json" ]]; then
    echo "nodejs"
  elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]]; then
    echo "python"
  elif [[ -f "go.mod" ]]; then
    echo "go"
  elif [[ -f "pom.xml" ]] || [[ -f "build.gradle" ]]; then
    echo "java"
  elif [[ -f ".csproj" ]] || [[ -f ".sln" ]]; then
    echo "dotnet"
  else
    echo "generic"
  fi
}
```

### 2. Security Control Matrix

| Security Control | Rust | Node.js | Python | Go | Java | Generic |
|-----------------|------|---------|--------|----|----- |---------|
| **Secret Detection** | âœ… | âœ… | âœ… | âœ… | âœ… | âœ… |
| **Dependency Scanning** | cargo-audit | npm audit | safety | govulncheck | OWASP | gitleaks |
| **Code Formatting** | cargo fmt | prettier | black | gofmt | google-java-format | - |
| **Linting** | clippy | eslint | pylint/flake8 | golint | spotbugs | - |
| **Testing** | cargo test | npm test | pytest | go test | mvn test | - |
| **License Check** | cargo-deny | license-checker | pip-licenses | go-licenses | license-maven | - |
| **SAST** | cargo-geiger | semgrep | bandit | gosec | spotbugs | semgrep |
| **Supply Chain** | cargo-auditable | npm audit | pip-audit | go mod | dependency-check | - |

### 3. Unified Pre-Push Hook Architecture

```bash
# Language-agnostic framework with pluggable checks
generate_pre_push_hook() {
  local language="$1"

  cat <<HOOK_START
#!/bin/bash
set -euo pipefail

# Pre-push hook for security validation ($language)
# Generated by 1-Click GitHub Security v${SCRIPT_VERSION}

echo "ðŸ” Running pre-push validation checks..."

# Universal security checks (all languages)
check_secrets() {
  # Use gitleakslite/gitleaks for secret detection
}

check_pinning() {
  # Use pinactlite for GitHub Actions SHA pinning
}

check_large_files() {
  # Prevent accidental large file commits
}

HOOK_START

  # Language-specific checks
  case "$language" in
    "rust")
      cat <<'RUST_CHECKS'
# Rust-specific checks
check_rust_format() {
  cargo fmt --check
}

check_rust_lint() {
  cargo clippy -- -D warnings
}

check_rust_test() {
  cargo test
}

check_rust_audit() {
  if command -v cargo-deny >/dev/null 2>&1; then
    cargo deny check
  else
    cargo audit
  fi
}

# Execute Rust checks
run_checks() {
  check_secrets
  check_pinning
  check_large_files
  check_rust_format
  check_rust_lint
  check_rust_test
  check_rust_audit
}
RUST_CHECKS
      ;;
    "nodejs")
      cat <<'NODEJS_CHECKS'
# Node.js-specific checks
check_nodejs_format() {
  if command -v prettier >/dev/null 2>&1; then
    prettier --check .
  fi
}

check_nodejs_lint() {
  if command -v eslint >/dev/null 2>&1; then
    eslint .
  fi
}

check_nodejs_test() {
  npm test
}

check_nodejs_audit() {
  npm audit --audit-level=moderate
}

# Execute Node.js checks
run_checks() {
  check_secrets
  check_pinning
  check_large_files
  check_nodejs_format
  check_nodejs_lint
  check_nodejs_test
  check_nodejs_audit
}
NODEJS_CHECKS
      ;;
    "python")
      cat <<'PYTHON_CHECKS'
# Python-specific checks
check_python_format() {
  if command -v black >/dev/null 2>&1; then
    black --check .
  fi
}

check_python_lint() {
  if command -v flake8 >/dev/null 2>&1; then
    flake8
  elif command -v pylint >/dev/null 2>&1; then
    pylint **/*.py
  fi
}

check_python_test() {
  if command -v pytest >/dev/null 2>&1; then
    pytest
  elif [[ -f "test_*.py" ]] || [[ -f "*_test.py" ]]; then
    python -m unittest discover
  fi
}

check_python_audit() {
  if command -v safety >/dev/null 2>&1; then
    safety check
  fi
}

# Execute Python checks
run_checks() {
  check_secrets
  check_pinning
  check_large_files
  check_python_format
  check_python_lint
  check_python_test
  check_python_audit
}
PYTHON_CHECKS
      ;;
    "go")
      cat <<'GO_CHECKS'
# Go-specific checks
check_go_format() {
  gofmt -d .
  if [[ $(gofmt -l . | wc -l) -ne 0 ]]; then
    echo "Go formatting issues found"
    return 1
  fi
}

check_go_lint() {
  if command -v golint >/dev/null 2>&1; then
    golint ./...
  fi
}

check_go_test() {
  go test ./...
}

check_go_audit() {
  if command -v govulncheck >/dev/null 2>&1; then
    govulncheck ./...
  fi
}

# Execute Go checks
run_checks() {
  check_secrets
  check_pinning
  check_large_files
  check_go_format
  check_go_lint
  check_go_test
  check_go_audit
}
GO_CHECKS
      ;;
    *)
      cat <<'GENERIC_CHECKS'
# Generic checks (no language-specific tools)
run_checks() {
  check_secrets
  check_pinning
  check_large_files
  echo "âœ… Generic security checks passed"
}
GENERIC_CHECKS
      ;;
  esac

  cat <<'HOOK_END'

# Execute all checks
run_checks

echo "âœ… All pre-push validation checks passed!"
HOOK_END
}
```

### 4. Language-Specific Tool Installation

```bash
install_language_tools() {
  local language="$1"

  case "$language" in
    "rust")
      install_rust_tools
      ;;
    "nodejs")
      install_nodejs_tools
      ;;
    "python")
      install_python_tools
      ;;
    "go")
      install_go_tools
      ;;
    *)
      print_status $BLUE "ðŸ“¦ Installing generic security tools only"
      ;;
  esac
}

install_nodejs_tools() {
  print_section "Installing Node.js Security Tools"

  local tools=(
    "eslint"
    "prettier"
    "audit-ci"
    "license-checker"
    "semgrep"
  )

  for tool in "${tools[@]}"; do
    if ! command -v "$tool" &>/dev/null; then
      print_status $YELLOW "ðŸ“¦ Installing $tool..."
      if [[ $DRY_RUN == true ]]; then
        print_status $BLUE "   [DRY RUN] Would install $tool"
      else
        npm install -g "$tool" || print_status $YELLOW "âš ï¸ Failed to install $tool"
      fi
    else
      print_status $GREEN "âœ… $tool already installed"
    fi
  done
}

install_python_tools() {
  print_section "Installing Python Security Tools"

  local tools=(
    "black"
    "flake8"
    "pylint"
    "safety"
    "bandit"
    "pip-audit"
  )

  for tool in "${tools[@]}"; do
    if ! command -v "$tool" &>/dev/null; then
      print_status $YELLOW "ðŸ“¦ Installing $tool..."
      if [[ $DRY_RUN == true ]]; then
        print_status $BLUE "   [DRY RUN] Would install $tool"
      else
        pip install "$tool" || print_status $YELLOW "âš ï¸ Failed to install $tool"
      fi
    else
      print_status $GREEN "âœ… $tool already installed"
    fi
  done
}

install_go_tools() {
  print_section "Installing Go Security Tools"

  local tools=(
    "golang.org/x/tools/cmd/goimports"
    "golang.org/x/vuln/cmd/govulncheck"
    "golang.org/x/lint/golint"
    "github.com/securecodewarrior/sast-scan"
  )

  for tool in "${tools[@]}"; do
    local binary="${tool##*/}"
    if ! command -v "$binary" &>/dev/null; then
      print_status $YELLOW "ðŸ“¦ Installing $tool..."
      if [[ $DRY_RUN == true ]]; then
        print_status $BLUE "   [DRY RUN] Would install $tool"
      else
        go install "$tool@latest" || print_status $YELLOW "âš ï¸ Failed to install $tool"
      fi
    else
      print_status $GREEN "âœ… $binary already installed"
    fi
  done
}
```

### 5. Multi-Language CI/CD Workflows

```yaml
# Template structure for language-specific CI workflows
name: Security CI

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  # Universal security jobs (all languages)
  secret-scanning:
    name: Secret Scanning
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2

  pinning-validation:
    name: SHA Pinning Validation
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check SHA Pins
        run: pinact run --check

  # Language-specific security jobs
  {language}-security-audit:
    name: {Language} Security Audit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      # Language-specific steps generated dynamically
```

### 6. Configuration Management

```bash
# Language-specific configuration files
create_language_config() {
  local language="$1"

  case "$language" in
    "nodejs")
      create_eslint_config
      create_prettier_config
      ;;
    "python")
      create_pyproject_config
      create_flake8_config
      ;;
    "go")
      create_golangci_config
      ;;
  esac
}

create_eslint_config() {
  if [[ ! -f ".eslintrc.js" ]] && [[ ! -f ".eslintrc.json" ]]; then
    cat > ".eslintrc.js" <<'EOF'
module.exports = {
  extends: ['eslint:recommended'],
  env: {
    node: true,
    es2021: true
  },
  rules: {
    'no-console': 'warn',
    'no-unused-vars': 'error'
  }
};
EOF
    print_status $GREEN "âœ… Created .eslintrc.js"
  fi
}
```

### 7. Migration Strategy

1. **Phase 1**: Repository rename from `1-click-rust-sec` to `1-click-github-sec`
2. **Phase 2**: Implement language detection and Node.js support
3. **Phase 3**: Add Python and Go support
4. **Phase 4**: Expand to Java, .NET, and other languages
5. **Phase 5**: Advanced multi-language features (polyglot projects)

### 8. Backward Compatibility

- Existing `--non-rust` flag becomes `--language=generic`
- Rust remains the default for projects with `Cargo.toml`
- All current Rust-specific functionality preserved
- Installer maintains same command-line interface

### 9. Performance Considerations

- Language-specific tools only installed when needed
- Pre-push hooks optimized per language (< 60s target maintained)
- Caching strategies adapted for each ecosystem
- Parallel execution where possible

### 10. Future Extensions

- **Polyglot project support**: Multiple languages in one repository
- **Custom security profiles**: Industry-specific security requirements
- **Enterprise integrations**: LDAP, SSO, policy management
- **Advanced SAST**: Language-specific static analysis beyond basic linting
- **Container security**: Docker, Kubernetes security scanning
- **Infrastructure as Code**: Terraform, CloudFormation security

## Implementation Priority

1. **High Priority**: Node.js/JavaScript/TypeScript support (large ecosystem)
2. **Medium Priority**: Python support (popular for security tools)
3. **Medium Priority**: Go support (growing in infrastructure/security)
4. **Lower Priority**: Java, .NET, PHP, Ruby (enterprise/specific use cases)

This architecture maintains the core security-first principles while expanding to serve the broader development community beyond just Rust projects.